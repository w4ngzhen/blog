---
layout: post
title: Linux下关于用户账户的几个文件解析
date: 2018-03-09
tags: 
- Linux
categories: 
- 技术
---

Linux是一个多用户系统，但是对于一个多用户共存的系统中，当然不能够出现用户相互越权等一系列的安全问题，所以如何正确的管理账户成为了Linux系统中至关重要的一环。

<!-- more -->

在Linux下，与用户账户有着紧密联系的文件又如下的几个：

```shell
/etc/passwd   #管理用户的UID、GID等重要用户信息
/etc/shadow   #管理用户密码的等重要信息
/etc/group    #管理用户组
/etc/gpasswd  #管理用户组密码
```
**1./etc/passwd**

虽说这个文件的文件名写着passwd，但是里面并没有存放密码（早起存放，后来为了安全将密码分离出来）

打开该文件，里面的内容大致如下：
```shell
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
...
```
上面的每一行代表了存在你系统中的一个用户。按照“:”来进行字段的划分，可以划分为7个字段，从左到右依次如下意义：

* **账号名称（1）**。用以来对应UID，例如上面的第一行root。
* **密码位（2）**。早期的该字段的确用来存放密码，但是这个文件特性是所有程序都能读取，为了安全起见，后来将密码放置在了/etc/shadow中了，所以这里只有一个“x”。
* **UID（3）**。用户标识，在Linux中，该UID是整数。且多个账号可以对应一个UID，因为Linux系统内核只认UID的。不同的区间有不同的意义：
0（系统管理员）。如果你希望其他的某些账号也是系统管理员，可以讲其UID修改为0。（极度不推荐，一是安全性，二是UID还与多处文件及系统有关联，单一修改往往设置不全会出问题）
1～499。保留给系统账户使用的ID，不强制，只是一个习惯。
500～2^32-1。给一般用户使用的。
* **GID（4）**。这个与/etc/group有关，即与用户组相关，后续会提到。
* **用户信息说明（5）**。没有重要用途，单纯作简单描述。
* **主文件夹（6）**。例如上面的/root目录，当root登陆以后，直接进入root的主目录中。当然你可以进行个性化配置。
* **Shell（7）**。当用户root登陆以后，会查找该字段并使用该字段指定的shell（这里是/bin/bash）。但这是里有一个特殊的shell（nologin）可以用来替代成让账号无法取得shell环境的登陆操作。譬如，你当然不希望一个在你Linux上的邮件账户来通过shell操作你的电脑。

当然，如果记不住的话，可以使用finger命令与id命令，例如：
```shell
finger root
# 输出如下：
Login: root           			Name: root
Directory: /root                    	Shell: /bin/bash
On since Fri Mar  9 19:10 (CST) on tty1   7 seconds idle
Mail last read Sat Mar  3 15:58 2018 (CST)
No Plan.

id root
# 输出如下：
uid=0(root) gid=0(root) groups=0(root)
```
输出内容不在解释，十分 -h 了。

**2./etc/shadow**

打开该文件，内容大致如下：
```shell
root:$6$tVBKdRxY$myJhWrhIwlXh42zNYLz1fmwu4ONQWP03O/5ccx1/34koU8GTn0M0ACx3xI4Bl.wPN3DPrrGbQX7vbPqqR//xv0:17593:0:99999:7:::
bin:*:17110:0:99999:7:::
daemon:*:17110:0:99999:7:::
adm:*:17110:0:99999:7:::
```
shadow文件夹自然也以“:”作为分隔符，这里一共有9个字段，从左到右依次具有如下意义：

* **账号名称（1）**。
* **密码（2）**。该处使用了摘要加密技术，即不容易逆向破译，只可做验证。
* **最近改动密码的日期（3）**。自1970年1月1日以来累加的天数。
* **密码不可被改动的天数（4）**。相当于改密码的冻结天数。root中为0代表你随时可以更改，如果修改为20就代表了20天内不可修改。
* **密码需要重新更改的天数（5）**。这里root行填写的99999代表了root的密码在99999天以内需要修改，可以理解为允许你永不更改。
* **密码需要更改前的警告天数（6）**。这一字段与上一字段配合。例如，上一字段设置为了20，即希望你在20天要重新修改密码，这里设置为5，就代表了第15天到第20天之前你登录的时候会提示你洗修改密码。
* **密码过期后的账号宽限天数（7）**。例如，在字段（5）设置为了20，即希望你在20天内要修改密码，但是你在20天以后都还没有修改，那么该密码就过期了（密码过期你的账户依然可以使用bash等，但是重新登录时系统会提醒你修改密码），在过期期间你还没有修改密码，那么这个账户就失效了，该账号再也无法使用该密码登录了。
* **账号失效日期（8）**。同样基于1970年1月1号以来的天数，日期到了以后，该账号会直接失效，与账号是否过期无关。
* **保留（9）。**

**3./etc/group**

/etc/group文件中存放的是用户组的相关的信息，打开大致如下：
```shell
root:x:0:root
```
一共有四个字段：
* **用户组名称(1)**。
* **用户组密码(2)**。通常不需要设置，是给“用户组管理员”来使用的。
* **GID(3)**。/etc/passwd中第四个字段使用GID就是对应于此的。
* **此用户组支持的账户名(4)**。当我们想要将一个用户添加到该用户组时，就可以将其写在该字段中，使用“,“无空格连接。

**4./etc/gpasswd**

/etc/gpasswd文件中存放的是用户组没密码的相关信息，大致如下：
```shell
root:::root
```

同样有四个字段：
* **用户组名(1)**。
* **密码(2)**。
* **用户组管理员账号(3)**。
* **该用户组所属账号(4)**。

当然，对于一个用户来说，当然可以在多个组当中。但是，当我们使用一个账户进行某些操作时，系统如何判断我们当前属于哪个组呢？例如，当前有个文件属性如下：
```shell
----r----- root group1  x.txt
```
有一个用户名为user既属于group1又属于group2。那该用户到底能不能读取这个txt呢？

其实这就涉及到了一个有效用户组与初始用户组两个概念了。使用groups命令，可以看到类似如下的输出（这里模拟有groups1、2两个组）：
```shell
groups
# 输出
groups1 groups2
```
第一个就是有效用户。有效用户组意味着目前你身份是user，现在属于group1。所以你是可以读取那个txt的。如何进行切换呢？使用newgrp命令
```shell
newgrp group2
groups
# 输出
group2 group1
```
此时尝试读取x.txt会提示权限不足。

那么初始用户组是什么呢？其实就是/etc/passwd中的GID对应的用户组，也是我们在登陆是的第一个用户组。
